#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <regex.h>
#define AUTOR "Santiago"
#define VERSION "0.0.1"
/* The following is the size of a buffer to contain any error messages
   encountered when the regular expression is compiled. */
#define MAX_ERROR_MSG 0x1000 // usada para las expresiones regulares
// variables globales
int suspect = 0;
// longitud de la cadena para considerarse sospechosa
int LEN_STRING = 20;

// declaramos las funciones del programa
void analize_string(char *line);
void read_file(char *path_file);
void menu(int argc, char **argv);


int main(int argc, char **argv)
{
	//
	puts("############################################################################");
	menu(argc, argv);
	printf("\n\nActividad sospechosa: %i\n", suspect);
	puts("############################################################################");
	//
	return 1;
}

void menu(int argc, char **argv)
{
	if(argc >= 2)
	{
		if(strcmp(argv[1], "-p") == 0){
			//printf("path del archivo \n");
			if(argc >= 3){
				// validando el archivo
				int longitud = strlen(argv[2]);
				printf("longitud del file name: %i\n", longitud);
				if(longitud > 3 && longitud < 100){
					// enviamos: path_archivo, 
					read_file(argv[2]);
				}
				else{
					printf("el path debe estar formado por una longitud de [4-99] caracteres\n"); exit(-1);
				}
			}
			else{ 
				printf("ingresa un path de archivo valido\n"); exit(-1);
			}
		}
		else if(strcmp(argv[1], "-v") == 0){
			printf("version: %s\n", VERSION); exit(-1);
		}
		else if(strcmp(argv[1], "-h") == 0){
			printf("\t -h [help] \n");
			printf("\t -v [version] \n");
			printf("\t -i [information] \n");
			printf("\t -p [path] [file name]\n");
			printf("\t -u [upload] \n");
			exit(-1);
		}
		else{ 
			printf("error: unrecognized command\n"); printf("\t -h [help] \n"); exit(-1);
		}
	}
	else{ 
		printf("AntiMalware: fatal error: no input files\n"); printf("\t -h [help] \n"); exit(-1); 
	}
}

void read_file(char *path_file)
{
	FILE * my_file;
	my_file = fopen(path_file,"r");

	// si el contenido del archivo rs diferente a nulo
	if(my_file != NULL)
	{
		char caracteres[100];
		printf("\n*Contenido del archivo:\n");
		//int tmp_i = 0;

		while (feof(my_file) == 0){
			//tmp_i++;
			// el 100 es el tamaño de la cadena a leer
	 		fgets(caracteres,100,my_file);

	 		int longitud = strlen(caracteres);
	 		// validamos que almenos exista 1 caracter en la linea, a parte del salto de linea
			if(longitud <=1 ) {
				continue; // continua con la siguiente iteración del ciclo
			}
			else{
				//printf("%s",caracteres);
				analize_string(caracteres);
			}
	 	}
	}
	else{ 
		perror("no se ha podido leer el archivo"); exit(-1); 
	}
 	fclose(my_file);
 	printf("\n");
}

/* Compile the regular expression described by "regex_text" into
   "r". */

static int compile_regex (regex_t * r, const char * regex_text)
{
    int status = regcomp (r, regex_text, REG_EXTENDED|REG_NEWLINE);
    if (status != 0) {
	char error_message[MAX_ERROR_MSG];
	regerror (status, r, error_message, MAX_ERROR_MSG);
        printf ("Regex error compiling '%s': %s\n",
                 regex_text, error_message);
        return 1;
    }
    return 0;
}

/*
  Match the string in "to_match" against the compiled regular
  expression in "r".
 */

static int match_regex (regex_t * r, const char * to_match)
{
    /* "P" is a pointer into the string which points to the end of the
       previous match. */
    const char * p = to_match;
    /* "N_matches" is the maximum number of matches allowed. */
    const int n_matches = 10;
    /* "M" contains the matches found. */
    regmatch_t m[n_matches];

    while (1) {
        int i = 0;
        int nomatch = regexec (r, p, n_matches, m, 0);
        if (nomatch) {
            printf ("No more matches.\n");
            return nomatch;
        }
        for (i = 0; i < n_matches; i++) {
            int start;
            int finish;
            if (m[i].rm_so == -1) {
                break;
            }
            start = m[i].rm_so + (p - to_match);
            finish = m[i].rm_eo + (p - to_match);
            if (i == 0) {
                printf ("$& is ");
            }
            else {
                printf ("$%d is ", i);
            }
            printf ("'%.*s' (bytes %d:%d)\n", (finish - start),
                    to_match + start, start, finish);
        }
        p += m[0].rm_eo;
    }
    return 0;
}

void analize_string(char *line){
	/* no validamos la longitud de la cadena porque solo DEBERIAN pasar las cadenas mayores a 1 caracter */

	/* - Step 1:
		longitud de cadena
	*/

	// comaramos el numero de caracteres de la linea con el establecido en la var LEN_STRING, de ser mayor, se considera sospechoso
	if(strlen(line) > LEN_STRING){
		suspect++;
	}
	printf("longitud: %i \t", strlen(line));
	printf("line: %s", line);


	/* - Step 2:
			busqueda de caracteres NO validos
	*/
	/*
	regex_t r;
    const char * regex_text;
    const char * find_text;
    regex_text = "([[:digit:]]+)[^[:digit:]]+([[:digit:]]+)";
	find_text = "This 1 is nice 2 so 33 for 4254";
    printf ("Trying to find '%s' in '%s'\n", regex_text, find_text);
    compile_regex (& r, regex_text);
    match_regex (& r, find_text);
    regfree (& r);
	*/


	/* si la funcion es tipo void, es valido poner solo return; 
	y asi no devolvemos nada, esto se usa comunmente para indicar que no se devuleve nada, 
	pero se procesan los argumentos recibidos 
	*/
	return;
}









